#! /usr/bin/env ruby

require 'orocos'
$LOAD_PATH.unshift File.expand_path(File.dirname(__FILE__))
require 'vizkit'
require 'corridor_plan_controls'
require 'envire/raster_map_view'
require 'optparse'
include Orocos

def usage
    STDERR.puts "scripts/run [-t task_name] <classes_file> <map_file> <expand_factor> [mls_env]"
    exit 1
end

task_name = nil
strong_edge_path, strong_edge_map, strong_edge_band, strong_edge_threshold = nil
opt_parse = OptionParser.new do |opt|
    opt.banner = "run [-t task_name] <classes_file> <map_file> <expand_factor> [mls_env]"
    opt.on('-t TASK_NAME', String, 'connect to the given task instead of starting our own') do |name|
        task_name = name
    end
end

remaining = opt_parse.parse(ARGV)
if remaining.size != 3 && remaining.size != 4
    exit 1
end

require 'envire/gdal'

BASE_DIR = File.expand_path('..', File.dirname(__FILE__))
ENV['PKG_CONFIG_PATH'] = "#{File.join(BASE_DIR, 'build')}:#{ENV['PKG_CONFIG_PATH']}"

Orocos.initialize
Orocos.load_typekit 'corridor_planner'

classes_path = File.expand_path(remaining.shift)
map_path     = File.expand_path(remaining.shift)
if !File.exists?(classes_path)
    STDERR.puts "#{classes_path} does not exist"
    exit 1
end
if !File.exists?(map_path)
    STDERR.puts "#{map_path} does not exist"
    exit 1
end
expand_factor        = Float(remaining.shift)
mls_env = remaining.shift

# Get the UI
main = Vizkit.default_loader.load(File.join(BASE_DIR, "scripts", "corridor_planner.ui"))

# Setup the map viewer. We will use it to pick the start and end point
main.map_view.extend RasterMapView
main.map_view.load(map_path)

# Setup the vizkit widget. In this one, we display the resulting plan
vizkit_widget = main.view3d
corridor_view = vizkit_widget.createPlugin('corridor_planner')
corridor_view.setAlpha(0.5)
corridor_view.setZOffset(0.05)
if mls_env
    corridor_view.setMLS(mls_env)
    envire_view = vizkit_widget.createPlugin('envire')
    envire_view.load(mls_env)
end

# Setup the control UI for displaying the plan
main.extend CorridorPlanControls
main.setupControls
main.corridor_view = corridor_view

# Set the image view up so that we pick the start point / target point there
start_point, target_point = nil, nil
# Planner task is set at the end of the script
planner_task = nil

main.status.setText("select start point")
main.map_view.connect(SIGNAL('clickImage(int,int)')) do |x, y|
    if !start_point
        start_point = main.map_view.viewToMap(x, y)
        puts "start point: #{start_point.inspect} (pixels=#{x} #{y})"
        main.status.setText("select target point")
        vizkit_widget.centralWidget.setCameraLookAt(start_point[0], start_point[1], 0)
        vizkit_widget.centralWidget.setCameraEye(start_point[0], start_point[1], 10)
    else
        target_point = main.map_view.viewToMap(x, y)
        puts "target point: #{target_point.inspect} (pixels=#{x} #{y})"

        median_point = start_point.zip(target_point).map { |a, b| (a + b) / 2 }
        up_vector    = start_point.zip(target_point).map { |a, b| (b - a) }
        length = Math.sqrt(up_vector.inject(0) { |length, v| v * v })
        vizkit_widget.centralWidget.setCameraLookAt(median_point[0], median_point[1], 0)
        vizkit_widget.centralWidget.setCameraEye(median_point[0], median_point[1], length)
        vizkit_widget.centralWidget.setCameraUp(up_vector[0], up_vector[1], 0)
        main.status.setText("computing")
        result = compute_plan(main.status, planner_task, map_path, classes_path, start_point, target_point, expand_factor)
        if result
            corridor_view.updatePlan(result)
            main.plan = result
        else
            main.status.setText("failed")
        end
        start_point = target_point = nil
    end
end

def compute_plan(status, task, map_path, classes_path, start_point, target_point, expand_factor)
    task.terrain_classes = classes_path
    task.map = map_path

    task.start_point  = Types::Base::Vector3d.new(start_point[0], start_point[1], 0)
    task.target_point = Types::Base::Vector3d.new(target_point[0], target_point[1], 0)

    task.margin    = expand_factor || 1.1
    task.min_width = 0

    task.configure
    task.start

    # To get the result when the task finished
    result_reader = task.plan.reader

    last_state = nil
    while true
        while task.state_changed?
            last_state = task.state(false)
            STDERR.puts last_state
            if status
                status.setText(last_state.to_s)
            end
        end

        if task.error?
            STDERR.puts "Failed ..."
            task.reset_exception
            break
        elsif !task.running?
            plan = result_reader.read
            STDERR.puts "found #{plan.corridors.size} corridors"
            File.open('result.dot', 'w') do |io|
                io.write plan.to_dot
            end
            break
        end
        $qApp.processEvents
        sleep 0.1
    end
    plan
end

if task_name
    planner_task = Orocos::TaskContext.get task_name
    main.show
    main.view3d.show
    Vizkit.exec
else
    Orocos::Process.spawn 'test_corridor_planner', :output => 'cplanner-log.txt' do |p|
        planner_task = p.task('planner')
        Orocos.log_all_ports
        Orocos.log_all_configuration
        main.show
        main.view3d.show
        Vizkit.exec
    end
end

